# Splitter

#### Introduction
Splitter is a logic program splitter to crack 1000 insts limits for the Mindustry game. It splits programs based on functions and generates [Schemacode](https://github.com/cardillan/mindcode/blob/main/doc/syntax/SCHEMACODE.markdown) or .msch files.

#### Structure

 - ### [Analysis.java](https://github.com/k88936/Splitter/blob/master/src/main/java/org/kvto/Analysis.java)
 Used to analyze the dependencies between functions and package multiple functions into a segment as a processor program.

 - ### [Generator.java](https://github.com/k88936/Splitter/blob/master/src/main/java/org/kvto/Generator.java)
 Generates some logic code for efficient implementation of function calls and return mechanisms.

 - ### [Module.java](https://github.com/k88936/Splitter/blob/master/src/main/java/org/kvto/Module.java)
 **Abstract class that needs to be implemented**
 Represents the entire program and defines the framework (code other than functions) and parameters for main logic blocks and sub logic blocks. Also includes methods for parsing parameters. Please refer to the source code comments for more details.

 - ### [Segment.java](https://github.com/k88936/Splitter/blob/master/src/main/java/org/kvto/Segment.java)
 Collection of functions stored in a single processor.

 - ### [Splittable.java](https://github.com/k88936/Splitter/blob/master/src/main/java/org/kvto/Splittable.java)
 Parent class of Splittable and SplittableGroup.

 - ### [SplittableGroup.java](https://github.com/k88936/Splitter/blob/master/src/main/java/org/kvto/SplittableGroup.java)
 Abstracts  recursive functions into one function for easier program analysis.

 - ### [SplittableUnit.java](https://github.com/k88936/Splitter/blob/master/src/main/java/org/kvto/SplittableUnit.java)
 **Abstract class that needs to be implemented**
 Represents a function in a program. It needs to indicate whether it is a pure algorithm and define the method body generation.

 - ### [Splitter.java](https://github.com/k88936/Splitter/blob/master/src/main/java/org/kvto/Splitter.java)
 Main program.

#### Instructions
1. It is recommended to integrate Splitter into the compiler (to collect necessary information).
2. Splitter is a framework, and to make it compatible with your compiler, you often need to implement how your compiler handles functions. For example, if you want to call a recursive function in shared memory, you will often need to pass the stack pointer in the implementation of the recursive function call in Module using the methods from Generator. When parsing parameters for subroutine in Module, remember to parse the stack pointer.

> Represents the entire program and defines the framework (code other than functions) and parameters for main logic blocks and sub logic blocks. Also includes methods for parsing parameters. Please refer to the source code comments for more details.

3. Splitter supports label jumps for flexibility.

#### Principle
The essence of Splitter is to analyze the relationships between functions, split them into segments, and add a layer of communication wrappers for logical blocks based on the implementation mechanism of the original language. Specifically, the logic code generation part includes:

 - Generating framework code for main logic blocks and sub logic blocks, followed by appending function call labels and method bodies.
 - If a function is split into sub logic blocks within a logical block, the method body part will be replaced with a function call defined in Module, achieving seamless connection.
 - The code generated by Generator is statements that have been calculated based on the splitting and allocation of space on MemoryBank used for communication.

#### Features
1. Supports shared stacks, recursion, and lazy evaluation (perhaps the only advantage other than accommodating more code with multiple processors, but an effective method is needed to achieve this).
2. Supports recursive splitting.
3. Splitter reserves empty logic blocks (still generates basic framework) for easily converting existing logic code (e.g., transportation) into a simple function. Simply insert the function into the function part of an empty logic block. This step can be done by editing [Schemacode](https://github.com/cardillan/mindcode/blob/main/doc/syntax/SCHEMACODE.markdown).

#### Limitations
1. Do not expect high speed.
2. Originally designed to support function calls, so it is difficult to support languages based on macro substitution.
3. Does not support passing non-numeric variables.
4. Global variables can only be stored in the heap and shared. It is not recommended to pass out global variable values during function calls and modify variable values upon return.
5. Not yet completed.
